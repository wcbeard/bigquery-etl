-- Query generated by: templates/clients_daily_histogram_aggregates.sql.py

CREATE TEMPORARY FUNCTION get_keyval_pairs(y STRING)
RETURNS ARRAY<STRING>
LANGUAGE js
AS
  '''
  var z = new Array();
  node = JSON.parse(y);
  for (let [key, value] of Object.entries(node)) {
    z.push(`${key}:${value}`);
  }
  return z;
''';

-- convert a string like '[5, 6, 7]' to an array struct
CREATE TEMPORARY FUNCTION string_to_arr(y STRING)
RETURNS ARRAY<STRING>
LANGUAGE js
AS
  '''
  return JSON.parse(y);
''';

CREATE TEMP FUNCTION udf_get_bucket_range(histograms ARRAY<STRING>) AS (
  (
    WITH buckets AS (
      SELECT
        string_to_arr(JSON_EXTRACT(histogram, "$.range")) AS bucket_range,
        SAFE_CAST(JSON_EXTRACT(histogram, "$.bucket_count") AS INT64) AS num_buckets
      FROM
        UNNEST(histograms) AS histogram
      WHERE
        histogram IS NOT NULL
        AND JSON_EXTRACT(histogram, "$.range") IS NOT NULL
        AND JSON_EXTRACT(histogram, "$.bucket_count") IS NOT NULL
      LIMIT
        1
    )
    SELECT AS STRUCT
      SAFE_CAST(bucket_range[OFFSET(0)] AS INT64) AS first_bucket,
      SAFE_CAST(bucket_range[OFFSET(1)] AS INT64) AS last_bucket,
      num_buckets
    FROM
      buckets
  )
);

CREATE TEMP FUNCTION udf_get_histogram_type(histograms ARRAY<STRING>) AS (
  (
    SELECT
      --format:off
      CASE SAFE_CAST(JSON_EXTRACT(histogram, "$.histogram_type") AS INT64)
        WHEN 0 THEN 'histogram-exponential'
        WHEN 1 THEN 'histogram-linear'
        WHEN 2 THEN 'histogram-boolean'
        WHEN 3 THEN 'histogram-flag'
        WHEN 4 THEN 'histogram-count'
        WHEN 5 THEN 'histogram-categorical'
      END AS histogram_type
      --format:on
    FROM
      UNNEST(histograms) AS histogram
    WHERE
      histogram IS NOT NULL
      AND JSON_EXTRACT(histogram, "$.histogram_type") IS NOT NULL
    LIMIT
      1
  )
);

CREATE TEMP FUNCTION udf_aggregate_json_sum(histograms ARRAY<STRING>) AS (
  ARRAY(
    SELECT AS STRUCT
      SPLIT(keyval, ':')[OFFSET(0)] AS key,
      SUM(SAFE_CAST(SPLIT(keyval, ':')[OFFSET(1)] AS INT64)) AS value
    FROM
      UNNEST(histograms) AS histogram,
      UNNEST(get_keyval_pairs(JSON_EXTRACT(histogram, "$.values"))) AS keyval
    WHERE
      histogram IS NOT NULL
      AND JSON_EXTRACT(histogram, "$.values") IS NOT NULL
    GROUP BY
      key
  )
);

WITH extracted AS (
  SELECT
    *,
    DATE(submission_timestamp) AS submission_date,
    client_info.client_id,
    REPLACE(ping_info.ping_type, "_", "-") AS ping_type,
    COALESCE(
      SAFE_CAST(SPLIT(client_info.app_display_version, '.')[OFFSET(0)] AS INT64),
      0
    ) AS app_version,
    client_info.os AS os,
    client_info.app_build AS app_build_id,
    client_info.app_channel AS channel
  FROM
    `moz-fx-data-shared-prod.{{ source_table }}`
  WHERE
    DATE(submission_timestamp) = {{ submission_date }}
    AND client_info.app_channel IN ("release", "fenixProduction")
    AND client_info.client_id IS NOT NULL
),
histograms AS (
  SELECT
    {{ attributes }},
    ARRAY<STRUCT<metric STRING, value STRING>>[
      {{ histograms }}
    ] AS histogram_aggregates
  FROM
    extracted
),
filtered_aggregates AS (
  SELECT
    {{ attributes }},
    metric,
    value
  FROM
    histograms
  CROSS JOIN
    UNNEST(histogram_aggregates)
  WHERE
    value IS NOT NULL
),
aggregated AS (
  SELECT
    {{ attributes }}.
    metric,
    ARRAY_AGG(value) AS value
  FROM
    filtered_aggregates
  GROUP BY
    {{ attributes }},
    metric
)
SELECT
  {{ attributes }},
  ARRAY_AGG(
    STRUCT<
      metric STRING,
      metric_type STRING,
      key STRING,
      agg_type STRING,
      bucket_range STRUCT<first_bucket INT64, last_bucket INT64, num_buckets INT64>,
      value ARRAY<STRUCT<key STRING, value INT64>>
    >(
      metric,
      udf_get_histogram_type(value),
      '',
      'summed_histogram',
      udf_get_bucket_range(value),
      udf_aggregate_json_sum(value)
    )
  ) AS histogram_aggregates
FROM
  aggregated
GROUP BY
  {{ attributes }}
